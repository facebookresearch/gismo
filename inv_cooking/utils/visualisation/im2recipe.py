import copy
import math
from typing import Optional, Dict, Any
from PIL import Image

import torch
import numpy as np

from inv_cooking.datasets.recipe1m import Recipe1MDataModule
from inv_cooking.datasets.vocabulary import Vocabulary
from inv_cooking.training.image_to_recipe import ImageToRecipe


class Im2RecipeVisualiser:
    """
    Utils to visualise the recipes generated by im2recipe
    """

    def __init__(self, model: ImageToRecipe, data_module: Recipe1MDataModule):
        self.model = model
        self.data_module = data_module

    def visualize(
        self,
        swap_images: bool = False,
        gray_images: bool = False,
        with_substitutions: bool = False,
        batch_size: int = 0
    ):
        """
        Function that combines the sampling of an input, passing through the model,
        and display of the result.

        Use the other functions individually for finer control.
        """
        batch = self.sample_input(batch_size=batch_size)
        batch, losses, ingr_predictions, recipe_predictions = self.sample_output(
            batch,
            with_substitutions=with_substitutions
        )
        self.display_sample(batch, losses, ingr_predictions, recipe_predictions)

    def sample_input(self, batch_size: int = 0):
        """
        Sample a batch input from the data loader
        """
        loader = self.data_module.test_dataloader(batch_size=batch_size)
        return next(iter(loader))

    def sample_output(
        self,
        batch: Optional[dict] = None,
        with_substitutions: bool = False,
        swap_images: bool = False,
        gray_images: bool = False,
    ):
        """
        Sample an output, using the batch as input to generate the outputs
        or generating a new sample input if not provided
        """
        if batch is None:
            batch = self.sample_input()
        else:
            batch = copy.copy(batch)

        # Investigation of the importance of images:
        # - roll images (each input gets the image of the next input)
        # - replace images by gray images
        if swap_images:
            batch["image"] = batch["image"].roll(shifts=[1], dims=[0])
        elif gray_images:
            images = batch["image"]
            batch["image"] = torch.zeros(size=images.shape, dtype=images.dtype, device=images.device)
        else:
            batch["image"] = batch["image"]

        self.model.eval()
        ingredients = batch["ingredients"] if not with_substitutions else batch["substitution"]
        with torch.no_grad():
            losses, (ingr_predictions, recipe_predictions) = self.model(
                image=batch["image"],
                ingredients=ingredients,
                recipe=batch["recipe"],
                use_ingr_pred=False,
                compute_losses=True,
                compute_predictions=True,
            )
            return batch, losses, ingr_predictions, recipe_predictions

    def display_sample(
        self, batch: Dict[str, Any], losses: Dict[str, Any], ingr_predictions: torch.Tensor,
        recipe_predictions: torch.Tensor, start: int = 0, limit: int = -1
    ):
        """
        Display the outputs of the model in terms of text
        """

        num_recipes = recipe_predictions.shape[0]
        ingr_vocab = self.data_module.dataset_test.ingr_vocab
        instr_vocab = self.data_module.dataset_test.get_instr_vocab()

        if limit < 0:
            limit = num_recipes
        else:
            limit = min(limit, num_recipes)

        for i in range(start, start + limit):

            self.display_image(batch["image"][i])

            print("INGREDIENTS (GT):")
            self.display_ingredients(batch["ingredients"][i], ingr_vocab)

            print("INGREDIENTS (SUBS):")
            self.display_ingredients(batch["substitution"][i], ingr_vocab)

            print("RECIPE (GT):")
            self.display_recipe(batch["recipe"][i], instr_vocab)

            if ingr_predictions is not None:
                print("INGREDIENTS (PRED):")
                self.display_ingredients(ingr_predictions[i], ingr_vocab)

            print("RECIPE (PRED):")
            self.display_recipe(recipe_predictions[i], instr_vocab)

    @classmethod
    def display_image(cls, image_tensor: torch.Tensor):
        import matplotlib.pyplot as plt

        if image_tensor.ndim == 3:
            image = cls.tensor_to_image(image_tensor)
            plt.imshow(image)
            plt.axis("off")
        elif image_tensor.ndim == 4:
            num_images = image_tensor.size(0)
            images = [cls.tensor_to_image(t) for t in image_tensor]

            num_columns = 2
            num_rows = int(math.ceil(num_images / num_columns))
            fig, ax = plt.subplots(figsize=(4 * num_columns, 4 * num_rows), ncols=num_columns, nrows=num_rows)
            for i in range(num_images):
                x, y = divmod(i, num_columns)
                ax[x, y].imshow(images[i])
            plt.show()

    @staticmethod
    def tensor_to_image(tensor: torch.Tensor):
        with torch.no_grad():
            sigma = torch.as_tensor((0.229, 0.224, 0.225), dtype=tensor.dtype, device=tensor.device).view(-1, 1, 1)
            mu = torch.as_tensor((0.485, 0.456, 0.406), dtype=tensor.dtype, device=tensor.device).view(-1, 1, 1)
            tensor = (tensor * sigma) + mu
            tensor = tensor.permute((1, 2, 0))
            array = tensor.cpu().detach().numpy()
            array = np.uint8(array * 255)
            return Image.fromarray(array, mode="RGB")

    @staticmethod
    def display_ingredients(prediction: torch.Tensor, vocab: Vocabulary):
        ingredient_list = []
        for i in prediction.cpu().numpy():
            word = vocab.idx2word.get(i)
            if word != "<pad>":
                if isinstance(word, list):
                    ingredient_list.append(word[0])
                else:
                    ingredient_list.append(word)
        print(ingredient_list)

    @staticmethod
    def display_recipe(prediction: torch.Tensor, vocab: Vocabulary):
        sentence = ""
        for i in prediction.cpu().numpy():
            word = vocab.idx2word.get(i)
            if word == "<end>":
                print(sentence)
                break

            if word == "<eoi>":
                print(sentence)
                sentence = ""
            elif word != "<start>":
                sentence += " " + word
